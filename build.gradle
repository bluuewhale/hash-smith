plugins {
    id 'java'
    id 'signing'
    alias libs.plugins.jmh
    alias libs.plugins.maven.publish
}

group = 'io.github.bluuewhale'
version = '0.1.8'

java {
    toolchain.languageVersion = JavaLanguageVersion.of(21)
    withSourcesJar()
}

repositories {
    mavenCentral()
}

dependencies {
    jmhImplementation libs.jmh.core
    jmhAnnotationProcessor libs.jmh.processor
    jmhImplementation libs.eclipse.collections
    jmhImplementation libs.fastutil
}

testing.suites {
    test {
        useJUnitJupiter(libs.versions.junit.jupitor)

        dependencies {
            implementation libs.fastutil
            implementation libs.java.object.layout
            implementation libs.eclipse.collections
        }
    }
    apacheTest(JvmTestSuite) {
        useJUnitJupiter(libs.versions.junit.jupitor)

        dependencies {
            implementation(project())
            implementation(libs.commons.lang3)
            implementation(libs.commons.collections4)
            implementation(libs.commons.collections4) {
                artifact { classifier = "tests" }
            }
        }
    }
    googleTest(JvmTestSuite) {
        useJUnit()

        dependencies {
            implementation(project())
            implementation libs.guava.testlib
        }
    }
}

tasks.withType(Test).configureEach {
    jvmArgs '--add-modules', 'jdk.incubator.vector'
}

// JMH runs a separate bytecode generator task (jmhRunBytecodeGenerator) which reflectively loads
// benchmark classes. That generator must also enable the incubator Vector module, otherwise classloading
// can fail with NoClassDefFoundError: jdk/incubator/vector/* on some platforms.
tasks.withType(me.champeau.jmh.JmhBytecodeGeneratorTask).configureEach { t ->
    // Apply at configuration time (helps IDE/task inspection).
    t.jvmArgs.addAll('--add-modules', 'jdk.incubator.vector')
    // Re-apply right before execution (guards against later overwrites).
    t.doFirst {
        def extra = ['--add-modules', 'jdk.incubator.vector']
        def current = t.jvmArgs.getOrElse([])
        if (!current.containsAll(extra)) {
            t.jvmArgs.addAll(extra)
        }
    }
}

tasks.check.configure {
    dependsOn(tasks.withType(Test))
}

// JIT / ASM (HotSpot PrintAssembly) runner for SwissMap.findIndexHashed.
// Usage:
//   ./gradlew jitAsm | tee jit-asm.txt
// NOTE: PrintAssembly requires an hsdis library for your JDK. See docs/JIT-ASM.md.
tasks.register('jitAsm', JavaExec) {
    group = 'verification'
    description = 'Run a small harness that heats up SwissMap.findIndexHashed and prints the generated machine code via -XX:+PrintAssembly (requires hsdis).'

    classpath = sourceSets.test.runtimeClasspath
    mainClass = 'io.github.bluuewhale.hashsmith.SwissMapAsmProbe'

    jvmArgs = [
            '-Xms256m',
            '-Xmx256m',
            '-Xbatch',
            // Force C2 (server compiler) so the assembly reflects final hot-path optimizations.
            '-XX:-TieredCompilation',
            '-XX:CICompilerCount=2',
            '-XX:CompileThreshold=1000',
            // Assembly
            '-XX:+UnlockDiagnosticVMOptions',
            '-XX:+PrintAssembly',
            // Reduce noise: try to compile/print only the method we care about.
            '-XX:CompileCommand=quiet',
            '-XX:CompileCommand=compileonly,io.github.bluuewhale.hashsmith.SwissMap::findIndexHashed',
            '-XX:CompileCommand=print,io.github.bluuewhale.hashsmith.SwissMap::findIndexHashed',
    ]
}

// JIT / ASM (HotSpot PrintAssembly) runner for ConcurrentSwissMap.get (and the underlying SwissMap probe loop).
// Usage:
//   ./gradlew jitAsmConcurrent | tee jit-asm-concurrent.txt
// NOTE: PrintAssembly requires an hsdis library for your JDK.
tasks.register('jitAsmConcurrent', JavaExec) {
    group = 'verification'
    description = 'Run a small harness that heats up ConcurrentSwissMap.get and prints the generated machine code via -XX:+PrintAssembly (requires hsdis).'

    classpath = sourceSets.test.runtimeClasspath
    mainClass = 'io.github.bluuewhale.hashsmith.ConcurrentSwissMapAsmProbe'

    jvmArgs = [
            '-Xms256m',
            '-Xmx256m',
            '-Xbatch',
            // Force C2 (server compiler) so the assembly reflects final hot-path optimizations.
            '-XX:-TieredCompilation',
            '-XX:CICompilerCount=2',
            '-XX:CompileThreshold=1000',
            // Assembly
            '-XX:+UnlockDiagnosticVMOptions',
            '-XX:+PrintAssembly',
            // Reduce noise: try to compile/print only the methods we care about.
            '-XX:CompileCommand=quiet',
            '-XX:CompileCommand=compileonly,io.github.bluuewhale.hashsmith.ConcurrentSwissMap::get',
            '-XX:CompileCommand=print,io.github.bluuewhale.hashsmith.ConcurrentSwissMap::get',
            // Also print the underlying SwissMap probe loop to correlate costs.
            '-XX:CompileCommand=compileonly,io.github.bluuewhale.hashsmith.SwissMap::findIndexHashed',
            '-XX:CompileCommand=print,io.github.bluuewhale.hashsmith.SwissMap::findIndexHashed',
    ]
}

tasks.withType(JavaCompile).configureEach {
    options.compilerArgs += ['--add-modules', 'jdk.incubator.vector']
}

javadoc {
    options.addStringOption('-add-modules', 'jdk.incubator.vector')
}

jmh {
    warmupIterations = 3
    iterations = 5
    fork = 1
    benchmarkMode = ['avgt']
    timeUnit = 'ns'
    jvmArgs = ['--add-modules', 'jdk.incubator.vector']
}

mavenPublishing {
    publishToMavenCentral(com.vanniktech.maven.publish.SonatypeHost.CENTRAL_PORTAL)
    signAllPublications()
    coordinates("io.github.bluuewhale", "hashsmith", version)

    pom {
        name.set("HashSmith")
        description.set("High-performance open-addressing hash tables for the JVM.")
        url.set("https://github.com/bluuewhale/hash-smith")

        licenses {
            license {
                name.set("MIT License")
                url.set("https://opensource.org/licenses/MIT")
            }
        }
        developers {
            developer {
                id.set("bluuewhale")
                name.set("bluuewhale")
                url.set("https://github.com/bluuewhale")
            }
        }
        scm {
            connection.set("scm:git:https://github.com/bluuewhale/hash-smith.git")
            developerConnection.set("scm:git:ssh://git@github.com:bluuewhale/hash-smith.git")
            url.set("https://github.com/bluuewhale/hash-smith")
        }
    }
}

signing {
    useGpgCmd()
}

afterEvaluate {
    tasks.named("generateMetadataFileForMavenPublication") {
        dependsOn(tasks.named("plainJavadocJar"))
    }
}
